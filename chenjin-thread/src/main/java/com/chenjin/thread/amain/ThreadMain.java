package com.chenjin.thread.amain;

/**
 * 1、测试守护线程   主线程休眠完了守护线程也跟着终止了
 * 守护线程的意思：和主线程共死的，主线程退出来守护线程就一定会退出
 * 守护线程情况下finally中的代码不能保证一定执行
 * 测试守护线程的时候一定要使用main函数，用@Test函数是测试不出来的
 * 2、yield和sleep其实也就是时间等待的区别，简单理解为sleep(0)就是yield，yield是让出机会大家重新竞争cpu
 * 3、进程是所有线程的集合，每一个线程是进程中的一条执行路径。
 * 4、微波炉例子：sleep是有个时间，就相当于睡觉去了，时间不到我就不会过来竞争cpu资源的，yield就是我热完一个菜了，然后和大家一起重新排队，
 * 重新一起竞争cpu资源，可以简单理解为sleep(0)就相当于yield
 * 5、使用实现实现Runnable接口好，原因实现了接口还可以继续继承，继承了类不能再继承。
 * 6、使用多线程的目的是为了提高程序的运行效率
 * 7、分批发送短信、迅雷多线程下载等都可以使用多线程处理。
 * 8、当多个线程同时共享，同一个全局变量或静态变量，做写的操作时，可能会发生数据冲突问题，也就是线程安全问题。但是做读操作是不会发生数据冲突问题。
 * 9、为什么使用线程同步或使用锁能解决线程安全问题呢？
 * 答:将可能会发生数据冲突问题(线程不安全问题)，只能让当前一个线程进行执行。代码执行完成后释放锁，让后才能让其他线程进行执行。这样的话就可以解决线程不安全问题
 * 10、什么是多线程之间同步？
 * 答:当多个线程共享同一个资源,不会受到其他线程的干扰。
 * 11、什么是同步代码块？
 * 答:就是将可能会发生线程安全问题的代码，给包括起来。只能让当前一个线程进行执行，被包裹的代码执行完成之后才能释放所，让后才能让其他线程进行执行。
 * 12、问：如何解决多线程之间线程安全问题?
 * 答:使用多线程之间同步或使用锁(lock)。
 * 13、问:为什么使用线程同步或使用锁能解决线程安全问题呢？
 * 答:将可能会发生数据冲突问题(线程不安全问题)，只能让当前一个线程进行执行。被包裹的代码执行完成后释放锁，让后才能让其他线程进行执行。这样的话就可以解决线程不安全问题。
 * 14、多线程之间通讯，其实就是多个线程在操作同一个资源，但是操作的动作不同。
 * 15、wait与sleep区别：
 * 对于sleep()方法，我们首先要知道该方法是属于Thread类中的。而wait()方法，则是属于Object类中的。
 * sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。
 * 在调用sleep()方法的过程中，线程不会释放对象锁。
 * 而当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备
 * 获取对象锁进入运行状态。
 * 16、Lock 接口与 synchronized 关键字的区别：
 * lock是可以手动加锁、解锁的，synchronized是系统决定加锁的
 * 17、ReentrantLock是一个可重入的互斥锁，ReentrantLock由最近成功获取锁，还没有释放的线程所拥有
 * ，如a方法获取锁了，b方法也需要用这把锁，那b方法就可以直接用，不用再去竞争
 * 18、  对线程停止的理解：
 * 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。
 * 使用stop方法强行终止线程（这个方法不推荐使用，因为stop和suspend、resume一样，也可能发生不可预料的结果）。
 * 使用interrupt方法中断线程。 线程在阻塞状态，此方法注意一点，使用中断标识只是打了一个标记，
 * 真正终止线程要自己处理下，出现异常会重新将中断标志位置为false，此时应该重新在catch中调用interrupt，将
 * 中断标志位重新置为false，
 * 如果不出现异常，调用isInterrupted，如果中断位为true，中断线程就好了
 * 19、多线程有三大特性，原子性、可见性、有序性
 * 原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
 * 简单一个例子：银行转账：a账户扣款，b账户增加钱，一起成功或者一起失败这个就是原子性。int a=a+1;底层会调用赋值等运算操作，无法保证全部成功或者
 * 全部失败，就不具有原子性
 * 20、可见性
 * 当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
 * 若两个线程在不同的cpu，那么线程1改变了i的值还没刷新到主存，线程2又使用了i，那么这个i值肯定还是之前的，线程1对变量的修改线程没看到这就是可见性问题。
 * 21、有序性：
 * 程序执行的顺序按照代码的先后顺序执行。重排序在多线程环境下最终执行结果就不一定是对的了
 * 22、Java内存模型 jmm
 * 线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。
 * 23、volatile与synchronized区别
 * 仅靠volatile不能保证线程的安全性。（原子性）
 * ①volatile轻量级，只能修饰变量。synchronized重量级，还可修饰方法
 * ②volatile只能保证数据的可见性，不能用来同步，因为多个线程并发访问volatile修饰的变量不会阻塞。
 * synchronized不仅保证可见性，而且还保证原子性，因为，只有获得了锁的线程才能进入临界区，从而保证临界区中的所有语句都全部执行。多个线程争抢synchronized锁对象时，会出现阻塞。
 * 线程安全性包括两个方面，①可见性。②原子性。
 * 24、ThreadLocal提高一个线程的局部变量，访问某个线程拥有自己局部变量。
 * 　当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。
 * 简单理解 ThreadLocal就是从共享变量拷贝一份到自己的变量中去，是不用管和别的线程之间的通讯的
 * 25、线程池：线程池是指在初始化一个多线程应用程序过程中创建一个线程集合，然后在需要执行新的任务时重用这些线程而不是新建一个线程。
 * 线程池中线程的数量通常完全取决于可用内存数量和应用程序的需求。然而，增加可用线程数量是可能的。线程池中的每个线程都有被分配一个任务
 * ，一旦任务已经完成了，线程回到池子中并等待下一次分配任务。
 * 线程池作用：
 * 基于以下几个原因在多线程应用程序中使用线程是必须的：
 * 1. 线程池改进了一个应用程序的响应时间。由于线程池中的线程已经准备好且等待被分配任务，应用程序可以直接拿来使用而不用新建一个线程。
 * 2. 线程池节省了CLR 为每个短生存周期任务创建一个完整的线程的开销并可以在任务完成后回收资源。
 * 3. 线程池根据当前在系统中运行的进程来优化线程时间片。
 * 4. 线程池允许我们开启多个任务而不用为每个线程设置属性。
 * 5. 线程池允许我们为正在执行的任务的程序参数传递一个包含状态信息的对象引用。
 * 6. 线程池可以用来解决处理一个特定请求最大线程数量限制问题。
 * 26、线程池四种创建方式
 * Java通过Executors（jdk1.5并发包）提供四种线程池，分别为：
 * newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
 * newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
 * newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。
 * newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。
 */
public class ThreadMain {
    public static void main(String[] args) {
        System.out.println("本类说明对多线程的整体理解");
    }
}

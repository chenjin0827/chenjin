package com.chenjin.thread.main;

/**
 * 1、测试守护线程   主线程休眠完了守护线程也跟着终止了
 * 守护线程的意思：和主线程共死的，主线程退出来守护线程就一定会退出
 * 守护线程情况下finally中的代码不能保证一定执行
 * 测试守护线程的时候一定要使用main函数，用@Test函数是测试不出来的
 * 2、yield和sleep其实也就是时间等待的区别，简单理解为sleep(0)就是yield，yield是让出机会大家重新竞争cpu
 * 3、进程是所有线程的集合，每一个线程是进程中的一条执行路径。
 * 4、微波炉例子：sleep是有个时间，就相当于睡觉去了，时间不到我就不会过来竞争cpu资源的，yield就是我热完一个菜了，然后和大家一起重新排队，
 * 重新一起竞争cpu资源，可以简单理解为sleep(0)就相当于yield
 * 5、使用实现实现Runnable接口好，原因实现了接口还可以继续继承，继承了类不能再继承。
 * 6、使用多线程的目的是为了提高程序的运行效率
 * 7、分批发送短信、迅雷多线程下载等都可以使用多线程处理。
 * 8、当多个线程同时共享，同一个全局变量或静态变量，做写的操作时，可能会发生数据冲突问题，也就是线程安全问题。但是做读操作是不会发生数据冲突问题。
 * 9、为什么使用线程同步或使用锁能解决线程安全问题呢？
 * 答:将可能会发生数据冲突问题(线程不安全问题)，只能让当前一个线程进行执行。代码执行完成后释放锁，让后才能让其他线程进行执行。这样的话就可以解决线程不安全问题
 * 10、什么是多线程之间同步？
 * 答:当多个线程共享同一个资源,不会受到其他线程的干扰。
 * 11、什么是同步代码块？
 * 答:就是将可能会发生线程安全问题的代码，给包括起来。只能让当前一个线程进行执行，被包裹的代码执行完成之后才能释放所，让后才能让其他线程进行执行。
 * 12、问：如何解决多线程之间线程安全问题?
 * 答:使用多线程之间同步或使用锁(lock)。
 * 13、问:为什么使用线程同步或使用锁能解决线程安全问题呢？
 * 答:将可能会发生数据冲突问题(线程不安全问题)，只能让当前一个线程进行执行。被包裹的代码执行完成后释放锁，让后才能让其他线程进行执行。这样的话就可以解决线程不安全问题。
 * 14、多线程之间通讯，其实就是多个线程在操作同一个资源，但是操作的动作不同。
 * 15、wait与sleep区别：
 * 对于sleep()方法，我们首先要知道该方法是属于Thread类中的。而wait()方法，则是属于Object类中的。
 * sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。
 * 在调用sleep()方法的过程中，线程不会释放对象锁。
 * 而当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备
 * 获取对象锁进入运行状态。
 * 16、Lock 接口与 synchronized 关键字的区别：
 * lock是可以手动加锁、解锁的，synchronized是系统决定加锁的
 * 17、ReentrantLock是一个可重入的互斥锁，ReentrantLock由最近成功获取锁，还没有释放的线程所拥有
 * ，如a方法获取锁了，b方法也需要用这把锁，那b方法就可以直接用，不用再去竞争
 */
public class ThreadMain {
    public static void main(String[] args) {
        System.out.println("本类说明对多线程的整体理解");
    }
}

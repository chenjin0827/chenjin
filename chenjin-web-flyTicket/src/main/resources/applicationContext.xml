<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:util="http://www.springframework.org/schema/util"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:task="http://www.springframework.org/schema/task"
       xmlns:cache="http://www.springframework.org/schema/cache" xmlns:c="http://www.springframework.org/schema/c"
       xmlns:p="http://www.springframework.org/schema/p"
       xsi:schemaLocation="
       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.1.xsd
       http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache-4.1.xsd
		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd
		http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.1.xsd
http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.1.xsd
">

    <!-- 引入属性文件 多写几个classpath 不然取不到文件 -->
    <context:property-placeholder location="classpath:db.properties,classpath:public_system.properties,classpath:public_user.properties" />

    <!-- 自动扫描dao和service包(自动注入) -->
    <context:component-scan base-package="com.chenjin" >
        <context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller" />
        <!--<context:exclude-filter type="aspectj" expression="com.chenjin.common.cache..*" />-->
    </context:component-scan>

    <!-- 开启这个配置，spring才能识别@Scheduled注解   -->
   <!-- <task:annotation-driven scheduler="qbScheduler" mode="proxy"/>
    <task:scheduler id="qbScheduler" pool-size="10"/>-->
    <!-- 配置线程池 -->
    <bean id ="taskExecutor"  class ="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor" >
        <!-- 核心线程数量 -->
        <property name ="corePoolSize" value ="${Thread.corePoolSize}" />
        <!-- 线程池维护线程所允许的空闲时间 -->
        <property name ="keepAliveSeconds" value ="${Thread.keepAliveSeconds}" />
        <!-- 线程池维护线程的最大数量 -->
        <property name ="maxPoolSize" value ="${Thread.maxPoolSize}" />
        <!-- 线程池所使用的缓冲队列 -->
        <property name ="queueCapacity" value ="${Thread.queueCapacity}" />
    </bean>

    <cache:annotation-driven cache-manager="${system.cache}" key-generator="myKeyGenerator"/>

    <bean id="myKeyGenerator" class="com.chenjin.testPCQueue.common.cache.key.DefaultKeyGenerator" />

    <!-- 单机用ehcache -->
    <bean id="ehcacheManager" class="org.springframework.cache.ehcache.EhCacheCacheManager">
        <property name="cacheManager" ref="EhCacheManagerFactory" />
    </bean>

    <bean id="EhCacheManagerFactory"
          class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean">
        <property name="configLocation" value="classpath:ehcache.xml" />
        <property name="shared" value="true" />
    </bean>

    <!-- 集群用redis -->
    <bean id="redisManager" class="org.springframework.data.redis.cache.RedisCacheManager" c:template-ref="redisTemplate" />

    <bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate">
        <property name="connectionFactory"   ref="JedisConnectionFactory" />
    </bean>

    <bean id="JedisConnectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory"
          p:host-name="${redis.host}" p:port="${redis.port}"  p:pool-config-ref="poolConfig"/>

    <bean id="poolConfig" class="redis.clients.jedis.JedisPoolConfig">
        <property name="maxIdle" value="${redis.maxIdle}" />
        <property name="maxTotal" value="${redis.maxTotal}" />
        <property name="maxWaitMillis" value="${redis.maxWait}" />
        <property name="testOnBorrow" value="${redis.testOnBorrow}" />
    </bean>
    <bean id="jdbc" class="org.springframework.jdbc.core.JdbcTemplate">
        <constructor-arg ref="dataSource"></constructor-arg>
    </bean>
    <!-- 配置数据源 -->
    <bean name="dataSource" class="com.alibaba.druid.pool.DruidDataSource"
          init-method="init" destroy-method="close">
        <property name="driverClassName" value="${driverClassName}"></property>
        <property name="url" value="${jdbc_url}" />
        <property name="username" value="${jdbc_username}" />
        <property name="password" value="${jdbc_password}" />

        <!-- 初始化连接大小 -->
        <property name="initialSize" value="0" />
        <!-- 连接池最大使用连接数量 -->
        <property name="maxActive" value="${maxActive}" />
        <!-- 连接池最小空闲 -->
        <property name="minIdle" value="0" />
        <!-- 获取连接最大等待时间 -->
        <property name="maxWait" value="${maxWait}" />

        <property name="validationQuery" value="${validationQuery}" />
        <property name="testOnBorrow" value="false" />
        <property name="testOnReturn" value="false" />
        <property name="testWhileIdle" value="true" />

        <!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 -->
        <property name="timeBetweenEvictionRunsMillis" value="60000" />
        <!-- 配置一个连接在池中最小生存的时间，单位是毫秒 -->
        <property name="minEvictableIdleTimeMillis" value="25200000" />

        <!-- 打开removeAbandoned功能 -->
        <property name="removeAbandoned" value="true" />
        <!-- 1800秒，也就是30分钟 -->
        <property name="removeAbandonedTimeout" value="6000" />
        <!-- 关闭abanded连接时输出错误日志 -->
        <property name="logAbandoned" value="true" />

        <!-- 监控数据库 -->
        <!-- <property name="filters" value="mergeStat" /> -->
        <property name="filters" value="stat" />
    </bean>

    <!-- 配置hibernate session工厂 -->
    <bean id="sessionFactory"
          class="org.springframework.orm.hibernate4.LocalSessionFactoryBean">
        <property name="dataSource" ref="dataSource" />
        <property name="hibernateProperties">
            <props>
                <prop key="hibernate.hbm2ddl.auto">${hibernate.hbm2ddl.auto}</prop>
                <prop key="hibernate.dialect">${hibernate.dialect}</prop>
                <prop key="hibernate.show_sql">${hibernate.show_sql}</prop>
                <prop key="hibernate.format_sql">${hibernate.format_sql}</prop>
                <prop key="hibernate.jdbc.fetch_size">${hibernate.jdbc.fetch_size}</prop>
                <prop key="hibernate.jdbc.batch_size">${hibernate.jdbc.batch_size}</prop>
                <prop key="hibernate.connection.isolation">2</prop>
            </props>
        </property>
        <property name="entityInterceptor">
            <bean id="baseEntityInterceptor" class="com.chenjin.testPCQueue.common.framework.interceptor.BaseEntityInterceptor" />
        </property>
        <!-- 自动扫描注解方式配置的hibernate类文件 -->
        <property name="packagesToScan">
            <list>
                <value>com.chenjin.sys.entity</value>
            </list>
        </property>
    </bean>
    <bean id="shiroMyRealm" class="com.chenjin.testPCQueue.sys.service.realm.ShiroMyRealm">
    </bean>
    <!-- 重连策略 -->
    <bean id="retryPolicy" class="org.apache.curator.retry.ExponentialBackoffRetry">
        <!-- 间隔时间基数 -->
        <constructor-arg index="0" value="1000" />
        <!-- 重连策略 -->
        <constructor-arg index="1" value="3" />
    </bean>
    <bean id="curatorFramework" class="org.apache.curator.framework.CuratorFrameworkFactory" factory-method="newClient" init-method="start">
        <constructor-arg index="0" value="${zkclient.zkServers}" />
        <!-- sessionTimeoutMs会话超时时间，单位为毫秒。默认是60000ms  -->
        <constructor-arg index="1" value="${zkclient.sessionTimeout}" />
        <!-- connectionTimeoutMs连接创建超时时间，单位毫秒，默认15000ms -->
        <constructor-arg index="2" value="${zkclient.connectionTimeout}" />
        <constructor-arg index="3" ref="retryPolicy" />
    </bean>
    <bean id="zkSerializer" class="org.I0Itec.zkclient.serialize.SerializableSerializer">
    </bean>
    <bean id="zookeeperTemplate" class="com.chenjin.testPCQueue.common.cache.client.CuratorTemplate">
        <constructor-arg name="curatorFramework" ref="curatorFramework" />
        <property name="zkSerializer" ref="zkSerializer" />
    </bean>
    <bean id="shiroSessionDAO" class="com.chenjin.testPCQueue.common.cache.dao.ShiroSessionDAO">
        <property name="clientTemplate" ref="zookeeperTemplate" />
        <property name="parentPath" value="/ADMIN_SESSIONS" />
    </bean>
    <!-- 定时清理僵尸session，Shiro会启用一个后台守护线程定时执行清理操作 用户直接关闭浏览器造成的孤立会话 -->
    <bean id="sessionValidationScheduler"
          class="org.apache.shiro.session.mgt.ExecutorServiceSessionValidationScheduler">
        <property name="interval" value="3600000" />
        <property name="sessionManager" ref="sessionManager" />
    </bean>
    <!-- 指定本系统SESSIONID, 默认为: JSESSIONID 问题: 与SERVLET容器名冲突, 如JETTY, TOMCAT 等默认JSESSIONID,
		当跳出SHIRO SERVLET时如ERROR-PAGE容器会为JSESSIONID重新分配值导致登录会话丢失! -->
    <bean id="wapsession" class="org.apache.shiro.web.servlet.SimpleCookie">
        <constructor-arg name="name" value="WAPSESSIONID"/>
    </bean>
    <bean id="sessionManager"
          class="org.apache.shiro.web.session.mgt.DefaultWebSessionManager">
        <property name="globalSessionTimeout" value="1800000" />
        <property name="sessionDAO" ref="shiroSessionDAO" />
        <property name="sessionValidationScheduler" ref="sessionValidationScheduler" />
        <property name="sessionValidationSchedulerEnabled" value="true" />
        <property name="sessionIdCookie" ref="wapsession" />
    </bean>
    <!-- 需要使用cache的话加上这句 -->
    <bean id="shiroEhcacheManager" class="org.apache.shiro.cache.ehcache.EhCacheManager">
        <property name="cacheManagerConfigFile" value="classpath:spring-shiro-ehcache.xml" />
    </bean>
    <bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager">
        <property name="realm" ref="shiroMyRealm" />
        <property name="sessionManager" ref="sessionManager" />
        <property name="cacheManager" ref="shiroEhcacheManager" />
    </bean>
    <!-- 基于Form表单的身份验证过滤器 -->
    <bean id="formAuthenticationFilterhome" class="com.chenjin.testPCQueue.sys.service.realm.AuthenticationFilter">
        <property name="loginUrl" value="/home.jsp" />
    </bean>
    <bean id="formAuthenticationFilter" class="com.chenjin.testPCQueue.sys.service.realm.AuthenticationFilter">
        <property name="usernameParam" value="userName" />
        <property name="passwordParam" value="password" />
        <property name="loginUrl" value="/login.jsp" />
        <property name="successUrl" value="/home/index.htmlx" />
    </bean>
    <bean id="thirdAuthenticationFilter" class="com.chenjin.testPCQueue.sys.service.realm.AuthenticationFilter">
        <property name="loginUrl" value="/thirdLogin/zs.htmlx" />
        <property name="successUrl" value="/home/index.htmlx" />
    </bean>
    <bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean">
        <property name="securityManager" ref="securityManager" />
        <property name="unauthorizedUrl" value="/unauthorized.jsp" />
        <property name="filters">
            <util:map>
                <entry key="authchome" value-ref="formAuthenticationFilterhome" />
                <entry key="authc" value-ref="formAuthenticationFilter" />
                <entry key="thirdAuth" value-ref="thirdAuthenticationFilter" />
            </util:map>
        </property>
        <property name="filterChainDefinitions">
            <value>
                /home.jsp = authc
                /login.jsp = authc
                /index.jsp = authc
                /thirdLogin/zs.htmlx=thirdAuth
            </value>
        </property>
    </bean>
    <!--由zk做verifyCode存储容器 -->
    <bean id="verifyCodeDAO" class="com.chenjin.testPCQueue.common.cache.dao.VerifyCodeDAO">
        <property name="clientTemplate" ref="zookeeperTemplate" />
        <property name="parentPath" value="/SUPERVISE_VERIFYCODE" />
    </bean>

    <!-- 配置事务管理器 -->
    <bean name="transactionManager"
          class="org.springframework.orm.hibernate4.HibernateTransactionManager">
        <property name="dataSource" ref="dataSource" ></property>
        <property name="sessionFactory" ref="sessionFactory"></property>
    </bean>

    <!-- 注解方式配置事物 -->
    <tx:annotation-driven transaction-manager="transactionManager" />
    <bean id="taskLockDAO" class="com.chenjin.testPCQueue.common.cache.dao.TaskLockDAO">
        <property name="clientTemplate" ref="myEhcacheTemplate" />
    </bean>
    <cache:annotation-driven cache-manager="cacheManager" />
    <bean id="ehCacheManager"
          class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean">
        <property name="configLocation" value="classpath:ehcache.xml" />
        <property name="shared" value="true" />
    </bean>
    <bean id="cacheManager" class="org.springframework.cache.ehcache.EhCacheCacheManager">
        <property name="cacheManager" ref="ehCacheManager" />
    </bean>
    <bean id="myEhcacheTemplate" class="com.chenjin.testPCQueue.common.cache.client.MyEhcacheTemplate">
        <property name="ehCacheCacheManager" ref="cacheManager" />
    </bean>
</beans>